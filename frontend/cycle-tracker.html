<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Collection Tracker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: transparent;
      color: #e5e5e5;
      overflow: hidden;
    }

    #tracker-container {
      position: fixed;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      width: 280px;
      height: 650px;
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid rgba(217, 119, 6, 0.5);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.7);
      display: none;
      z-index: 10001;
    }

    #tracker-container.visible {
      display: flex;
      flex-direction: column;
    }

    /* Header with timer */
    .header {
      background: rgba(40, 40, 40, 0.95);
      padding: 10px 12px;
      border-bottom: 1px solid #555;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .timer-container {
      display: flex;
      gap: 4px;
      align-items: baseline;
    }

    .timer-label {
      font-size: 10px;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .timer-value {
      font-size: 13px;
      font-weight: bold;
      color: #fbbf24;
      font-variant-numeric: tabular-nums;
    }

    .close-btn {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      transition: color 0.2s;
    }

    .close-btn:hover {
      color: #fff;
    }

    /* Tabs */
    .tabs {
      display: flex;
      background: rgba(50, 50, 50, 0.8);
      border-bottom: 1px solid #555;
    }

    .tab {
      flex: 1;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      font-size: 12px;
      border: none;
      background: none;
      color: #999;
      transition: all 0.2s;
    }

    .tab.active {
      background: rgba(217, 119, 6, 0.3);
      color: #fbbf24;
      border-bottom: 2px solid #fbbf24;
    }

    .tab:hover {
      background: rgba(217, 119, 6, 0.2);
      color: #fbbf24;
    }

    /* Content area */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .content::-webkit-scrollbar {
      width: 6px;
    }

    .content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
    }

    .content::-webkit-scrollbar-thumb {
      background: rgba(217, 119, 6, 0.5);
      border-radius: 3px;
    }

    /* Set items - Ultra compact */
    .set-item {
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding-bottom: 4px;
    }

    .set-header {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 4px 2px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
      user-select: none;
    }

    .set-header:hover {
      background: rgba(217, 119, 6, 0.1);
    }

    .expand-icon {
      font-size: 10px;
      width: 12px;
      color: #999;
    }

    .set-emoji {
      font-size: 14px;
      width: 16px;
      text-align: center;
    }

    .set-progress {
      color: #9ca3af;
      min-width: 35px;
      font-size: 10px;
    }

    .set-name {
      flex: 1;
      font-size: 11px;
    }

    .set-name.complete {
      color: #10b981;
    }

    .eye-icon {
      cursor: pointer;
      font-size: 14px;
      padding: 2px;
      transition: all 0.2s;
    }

    .eye-icon.visible {
      color: #fbbf24;
    }

    .eye-icon.hidden {
      color: #6b7280;
      opacity: 0.5;
    }

    .eye-icon:hover {
      transform: scale(1.2);
    }

    /* Expanded items list - COMPACT 2-COLUMN */
    .items-list {
      display: none;
      padding: 4px 0 4px 20px;
      font-size: 11px;
    }

    .items-list.expanded {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }

    .item-compact {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      width: calc(50% - 2px);
      padding: 2px 4px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 10px;
    }

    .item-compact:hover {
      background: rgba(217, 119, 6, 0.1);
    }

    .item-checkbox {
      width: 12px;
      color: #9ca3af;
      flex-shrink: 0;
    }

    .item-checkbox.collected {
      color: #10b981;
    }

    .item-name {
      flex: 1;
      color: #d1d5db;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-name.collected {
      color: #6b7280;
      text-decoration: line-through;
    }

    /* Footer */
    .footer {
      background: rgba(40, 40, 40, 0.95);
      padding: 8px 12px;
      border-top: 1px solid #555;
      font-size: 11px;
      color: #9ca3af;
      text-align: center;
    }

    /* Loading state */
    .loading {
      padding: 20px;
      text-align: center;
      color: #9ca3af;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="tracker-container">
    <div class="header">
      <div class="timer-container">
        <span class="timer-label">Next:</span>
        <span class="timer-value" id="timer">00:00:00</span>
      </div>
      <button class="close-btn" id="close-btn">×</button>
    </div>
    <div class="tabs">
      <button class="tab active" data-tab="guaranteed">Sets</button>
      <button class="tab" data-tab="random">Random</button>
    </div>
    <div class="content" id="content">
      <div class="loading">Loading cycle data...</div>
    </div>
    <div class="footer" id="footer">Loading...</div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    // Global state
    const state = {
      expandedSets: {},
      visibilityMap: {},
      collectedItems: {},
      cycleData: null,
      itemsData: null,
      activeTab: 'guaranteed',
      lastRefreshTime: null
    };

    // Load persisted state
    function loadPersistedState() {
      try {
        const saved = localStorage.getItem('cycleTrackerState');
        if (saved) {
          const parsed = JSON.parse(saved);
          state.collectedItems = parsed.collectedItems || {};
          state.visibilityMap = parsed.visibilityMap || {};
          state.expandedSets = parsed.expandedSets || {};
        }
      } catch (e) {
        console.error('Failed to load persisted state:', e);
      }
    }

    // Save state
    function saveState() {
      try {
        localStorage.setItem('cycleTrackerState', JSON.stringify({
          collectedItems: state.collectedItems,
          visibilityMap: state.visibilityMap,
          expandedSets: state.expandedSets
        }));
      } catch (e) {
        console.error('Failed to save state:', e);
      }
    }

    // Countdown timer to 00:00 UTC
    function updateTimer() {
      const now = new Date();
      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);

      const tomorrow = new Date(utcNow);
      tomorrow.setUTCHours(24, 0, 0, 0);

      const diff = tomorrow - utcNow;

      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

      document.getElementById('timer').textContent = timeString;

      // Check if cycle just changed (00:00:00)
      if (hours === 0 && minutes === 0 && seconds === 0) {
        const today = utcNow.toISOString().split('T')[0];
        if (state.lastRefreshTime !== today) {
          console.log('Cycle changed! Refreshing data...');
          state.lastRefreshTime = today;
          loadRealData();
          // Also trigger backend refresh
          fetch('http://localhost:5000/refresh-data', { method: 'POST' })
            .then(res => res.json())
            .then(data => console.log('Backend data refreshed:', data))
            .catch(err => console.error('Failed to refresh backend:', err));
        }
      }
    }

    // Smart name shortening
    function shortenItemName(rawName, category) {
      let name = rawName;

      name = name
        .replace(/^(document_card_|provision_|consumable_)/, '')
        .replace(/^(hrlm_|egg_)/, '');

      if (name.includes('_random_')) {
        const match = name.match(/_random_(\d+)/);
        if (match) {
          return `#${match[1]}`;
        }
      }

      if (['cups', 'swords', 'wands', 'pentacles'].includes(category)) {
        name = name.replace(/_(cups|swords|wands|pentacles)$/, '');
      }

      if (category === 'egg') {
        name = name.replace(/_egg(_\d+)?$/, '');
      }

      if (category === 'flower') {
        name = name
          .replace(/^(american_wild_flower_|wild_flower_)/, '')
          .replace(/_(flower|blossom)$/, '');
      }

      if (category === 'heirlooms') {
        name = name
          .replace(/^(brush_|comb_|hairpin_)/, '')
          .replace(/_brush$/, ' Br.')
          .replace(/_comb$/, ' Cb.')
          .replace(/_hairpin$/, ' Pin');
      }

      name = name
        .replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      return name;
    }

    // Load real data from Joan Ropke API
    async function loadRealData() {
      try {
        const [cyclesResponse, itemsResponse] = await Promise.all([
          fetch('https://jeanropke.github.io/RDR2CollectorsMap/data/cycles.json'),
          fetch('https://jeanropke.github.io/RDR2CollectorsMap/data/items.json')
        ]);

        const cyclesData = await cyclesResponse.json();
        const itemsData = await itemsResponse.json();

        const now = new Date();
        const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
        const today = utcNow.toISOString().split('T')[0];

        const todayCycles = cyclesData.find(entry => entry.date === today);

        if (!todayCycles) {
          console.error('No cycle data for today:', today);
          document.getElementById('content').innerHTML = '<div class="loading">No cycle data available for today</div>';
          return null;
        }

        state.cycleData = todayCycles;
        state.itemsData = itemsData;
        state.lastRefreshTime = today;

        renderAll();
        return { cycles: todayCycles, items: itemsData };
      } catch (error) {
        console.error('Failed to load real data:', error);
        document.getElementById('content').innerHTML = '<div class="loading">Failed to load cycle data</div>';
        return null;
      }
    }

    // Parse real data into organized sets
    function parseRealData() {
      if (!state.cycleData || !state.itemsData) return null;

      const sets = [];
      const randomCategories = [];

      const categoryConfig = {
        'cups': { emoji: '🏆', name: 'Cups', type: 'guaranteed' },
        'swords': { emoji: '🎴', name: 'Swords', type: 'guaranteed' },
        'wands': { emoji: '⭐', name: 'Wands', type: 'guaranteed' },
        'pentacles': { emoji: '🃏', name: 'Pentacles', type: 'guaranteed' },
        'egg': { emoji: '🥚', name: 'Eggs', type: 'guaranteed' },
        'bottle': { emoji: '🍾', name: 'Bottles', type: 'guaranteed' },
        'flower': { emoji: '🌺', name: 'Flowers', type: 'guaranteed' },
        'heirlooms': { emoji: '👑', name: 'Heirlooms', type: 'guaranteed' },
        'arrowhead': { emoji: '🎯', name: 'Arrowheads', type: 'random' },
        'coin': { emoji: '🪙', name: 'Coins', type: 'random' },
        'fossils': { emoji: '🦴', name: 'Fossils', type: 'random' },
        'jewelry': { emoji: '💍', name: 'Jewelry', type: 'random' }
      };

      for (const [category, config] of Object.entries(categoryConfig)) {
        const cycleNum = state.cycleData[category];
        if (!cycleNum) continue;

        const categoryItems = state.itemsData[category];
        if (!categoryItems) continue;

        const cycleItems = categoryItems[String(cycleNum)];
        if (!cycleItems || !Array.isArray(cycleItems)) continue;

        const isRandom = cycleItems.some(item => item.text && item.text.includes('_random_'));

        const items = cycleItems.map((item) => {
          const rawName = item.text || 'Unknown';
          const readableName = shortenItemName(rawName, category);

          return {
            id: rawName,
            name: readableName,
            collected: false
          };
        });

        if (isRandom || config.type === 'random') {
          randomCategories.push({
            emoji: config.emoji,
            name: config.name,
            category: category,
            total: items.length,
            collected: 0,
            visible: true,
            items: items
          });
        } else {
          sets.push({
            emoji: config.emoji,
            name: config.name,
            category: category,
            total: items.length,
            collected: 0,
            visible: true,
            items: items
          });
        }
      }

      return { sets, randomCategories };
    }

    // Toggle functions
    function toggleSet(setName) {
      state.expandedSets[setName] = !state.expandedSets[setName];
      saveState();
      renderAll();
    }

    function toggleVisibility(setName) {
      state.visibilityMap[setName] = !state.visibilityMap[setName];
      saveState();
      renderAll();

      // Notify main window to update collectible visibility
      ipcRenderer.send('update-collectible-visibility', {
        category: setName,
        visible: state.visibilityMap[setName] !== false
      });
    }

    function toggleCollected(setName, itemId) {
      const key = `${setName}-${itemId}`;
      state.collectedItems[key] = !state.collectedItems[key];
      saveState();
      renderAll();
    }

    // Render guaranteed sets
    function renderGuaranteedSets(data) {
      if (!data || !data.sets) return '<div class="loading">No data available</div>';

      return data.sets.map(set => {
        const isExpanded = state.expandedSets[set.name];
        const isVisible = state.visibilityMap[set.name] !== false;
        const expandIcon = isExpanded ? '▼' : '▽';

        let collectedCount = 0;
        set.items.forEach(item => {
          const key = `${set.name}-${item.id}`;
          if (state.collectedItems[key]) collectedCount++;
        });

        const isComplete = collectedCount === set.total;

        let itemsHTML = '';
        if (isExpanded) {
          itemsHTML = `
            <div class="items-list expanded">
              ${set.items.map(item => {
                const key = `${set.name}-${item.id}`;
                const isCollected = state.collectedItems[key];

                return `
                  <div class="item-compact" onclick="toggleCollected('${set.name}', '${item.id}')">
                    <span class="item-checkbox ${isCollected ? 'collected' : ''}">
                      ${isCollected ? '✓' : '○'}
                    </span>
                    <span class="item-name ${isCollected ? 'collected' : ''}" title="${item.name}">
                      ${item.name}
                    </span>
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }

        return `
          <div class="set-item">
            <div class="set-header" onclick="toggleSet('${set.name}')">
              <span class="expand-icon">${expandIcon}</span>
              <span class="set-emoji">${set.emoji}</span>
              <span class="set-progress">${collectedCount}/${set.total}</span>
              <span class="set-name ${isComplete ? 'complete' : ''}">${set.name}</span>
              <span class="eye-icon ${isVisible ? 'visible' : 'hidden'}" onclick="event.stopPropagation(); toggleVisibility('${set.name}')">
                ${isVisible ? '👁️' : '👁️‍🗨️'}
              </span>
            </div>
            ${itemsHTML}
          </div>
        `;
      }).join('');
    }

    // Render random categories
    function renderRandomCategories(data) {
      if (!data || !data.randomCategories) return '<div class="loading">No data available</div>';

      return data.randomCategories.map(cat => {
        const isExpanded = state.expandedSets[cat.name];
        const isVisible = state.visibilityMap[cat.name] !== false;
        const expandIcon = isExpanded ? '▼' : '▽';

        let collectedCount = 0;
        cat.items.forEach(item => {
          const key = `${cat.name}-${item.id}`;
          if (state.collectedItems[key]) collectedCount++;
        });

        let itemsHTML = '';
        if (isExpanded) {
          itemsHTML = `
            <div class="items-list expanded">
              ${cat.items.map(item => {
                const key = `${cat.name}-${item.id}`;
                const isCollected = state.collectedItems[key];

                return `
                  <div class="item-compact" onclick="toggleCollected('${cat.name}', '${item.id}')">
                    <span class="item-checkbox ${isCollected ? 'collected' : ''}">
                      ${isCollected ? '✓' : '○'}
                    </span>
                    <span class="item-name ${isCollected ? 'collected' : ''}" title="${item.name}">
                      ${item.name}
                    </span>
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }

        return `
          <div class="set-item">
            <div class="set-header" onclick="toggleSet('${cat.name}')">
              <span class="expand-icon">${expandIcon}</span>
              <span class="set-emoji">${cat.emoji}</span>
              <span class="set-progress">${collectedCount}/${cat.total}</span>
              <span class="set-name">${cat.name}</span>
              <span class="eye-icon ${isVisible ? 'visible' : 'hidden'}" onclick="event.stopPropagation(); toggleVisibility('${cat.name}')">
                ${isVisible ? '👁️' : '👁️‍🗨️'}
              </span>
            </div>
            ${itemsHTML}
          </div>
        `;
      }).join('');
    }

    // Render all
    function renderAll() {
      const data = parseRealData();
      if (!data) return;

      const content = document.getElementById('content');

      if (state.activeTab === 'guaranteed') {
        content.innerHTML = renderGuaranteedSets(data);
      } else if (state.activeTab === 'random') {
        content.innerHTML = renderRandomCategories(data);
      }

      // Update footer
      const totalItems = data.sets.reduce((sum, set) => sum + set.total, 0) +
                        data.randomCategories.reduce((sum, cat) => sum + cat.total, 0);
      let totalCollected = 0;

      data.sets.forEach(set => {
        set.items.forEach(item => {
          const key = `${set.name}-${item.id}`;
          if (state.collectedItems[key]) totalCollected++;
        });
      });

      data.randomCategories.forEach(cat => {
        cat.items.forEach(item => {
          const key = `${cat.name}-${item.id}`;
          if (state.collectedItems[key]) totalCollected++;
        });
      });

      document.getElementById('footer').textContent =
        `${totalCollected}/${totalItems} collected (${Math.round(totalCollected/totalItems*100)}%)`;
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        state.activeTab = this.dataset.tab;
        renderAll();
      });
    });

    // Close button
    document.getElementById('close-btn').addEventListener('click', async () => {
      // Hide tracker in parent window
      window.parent.postMessage({ type: 'close-tracker' }, '*');
    });

    // Initialize
    async function init() {
      loadPersistedState();
      updateTimer();
      setInterval(updateTimer, 1000);
      await loadRealData();
    }

    init();
  </script>
</body>
</html>
